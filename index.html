<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>coming soon !!!</title>
	<link href='http://fonts.googleapis.com/css?family=Quicksand' rel='stylesheet' type='text/css'>
	<style>
		body {
			font-family: 'Quicksand', sans-serif;
			margin: 0;
			height: auto;
		}
		section {
			height: 100%;
			margin: auto;
		}
		header {
			position: fixed;
			color:#000;
			font-size: 2em;
			z-index: 1;
			width: 80%;
			height: 20%;
			margin-left: 10%;
			margin-right: 10%;
		}
		header:hover {
    	height: 10%;
		}
		header div{
			top: 0;
		}
		header:hover {
    	height: 10%;
		}
		h1 {
			font-weight: normal;
		}
		ul {
			text-align: left;
			margin-top: 120px;
		}
		#rec{
			position: fixed;
			float: left;
			width: 50%;
			height: 50%;
			top: 27%;
			margin-left: 20%;
		}
		footer {
		  position: fixed;;
		  right: 0;
		  bottom: 0;
		  left: 0;
		  padding: 1rem;
		  background-color: #efefef;
		  text-align: center;
			z-index: 1;
}
	</style>
</head>

<body>

	<section>
		<header>
			<img src="img/frame.png" alt="frame" data-parallax='{"x": 0, "from-scroll": 50, "distance": 0, "smoothness": 10}'
						data-0="background-image:linear-gradient(0deg, hsl(150, 2%, 100%), hsl(150, 2%, 100%));"
						data-200="background-image:linear-gradient(360deg, hsl(150, 90%, 50%), hsl(150, 90%, 50%));"/>
			<img src="img/t.png" alt="t" data-parallax='{"x": -160, "from-scroll": 70, "distance": 0, "smoothness": 20}'/>
			<img src="img/s.png" alt="s" data-parallax='{"x": -226, "from-scroll": 90, "distance": 0, "smoothness": 30}'/>
			<div style="float: right;" data-parallax='{"y": 110, "from-scroll": 50, "distance": 0, "smoothness": 40}'>
				"Everything is a function of time"
			</div>
		</header>
		<div id='rec'>
			<canvas id='canvasID' style="position: absolute; left: 0px; top: 0px;"></canvas>
		</div>
		<footer>
  	<p>todo</p>
		</footer>
	</section>
	<script src="js/jquery-2.1.3.min.js"></script>
	<script src="js/jquery.easing.1.3.js"></script>
	<script src="js/jquery.parallax-scroll.js"></script>
	<script src="js/skrollr.js"></script>
	<script type="text/javascript">
		skrollr.init();
	</script>
	<script src="js/three.js"></script>
	<script src="js/Projector.js"></script>
	<script src="js/CanvasRenderer.js"></script>
	<script src="js/stats.min.js"></script>
	<script src="js/tween.min.js"></script>

	<script>
	var container, stats;
	var camera, scene, renderer;

	var raycaster;
	var mouse;

	init();
	animate();

	function init() {

		container = document.getElementById('rec');
		//container = document.createElement( 'div' );
		document.getElementsByTagName('section')[0].appendChild( container );

		/*var info = document.createElement( 'div' );
		info.style.position = 'absolute';
		info.style.top = '10px';
		info.style.width = '100%';
		info.style.textAlign = 'center';
		info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - clickable objects';
		container.appendChild( info );*/

		camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.y = 300;
		camera.position.z = 500;

		scene = new THREE.Scene();

		var geometry = new THREE.BoxGeometry( 100, 200, 10 );

		for ( var i = 0; i < 3; i ++ ) {

			var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, opacity: 0.6 } ) );
			object.position.x = Math.random() * 800 - 400;
			object.position.y = object.position.x + 150;
			//object.position.z = object.position.y + 150;
			//object.scale.x = Math.random() * 2 + 1;
			//object.scale.y = Math.random() * 2 + 1;
			//object.scale.z = Math.random() * 2 + 1;
			//object.rotation.x = Math.random() * 2 * Math.PI;
			//object.rotation.y = Math.random() * 2 * Math.PI;
			//object.rotation.z = Math.random() * 2 * Math.PI;
			scene.add( object );

		}

		//

		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		var canvas = document.getElementById("canvasID");
		renderer = new THREE.CanvasRenderer({ canvas: canvas });
		//renderer = new THREE.CanvasRenderer();
		renderer.setClearColor( 0xf0f0f0 );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( 300, 300 );
		container.appendChild(renderer.domElement);

		stats = new Stats();
		//container.appendChild( stats.dom );

		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'touchstart', onDocumentTouchStart, false );

		//

		window.addEventListener( 'resize', onWindowResize, false );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, document.body.clientHeight );

	}

	function onDocumentTouchStart( event ) {

		event.preventDefault();

		event.clientX = event.touches[0].clientX;
		event.clientY = event.touches[0].clientY;
		onDocumentMouseDown( event );

	}

	function onDocumentMouseDown( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( scene.children );

		if ( intersects.length > 0 ) {

			new TWEEN.Tween( intersects[ 0 ].object.position ).to( {
				x: Math.random() * 800 - 400,
				y: Math.random() * 800 - 400,
				z: Math.random() * 800 - 400 }, 2000 )
			.easing( TWEEN.Easing.Elastic.Out).start();

			new TWEEN.Tween( intersects[ 0 ].object.rotation ).to( {
				x: Math.random() * 2 * Math.PI,
				y: Math.random() * 2 * Math.PI,
				z: Math.random() * 2 * Math.PI }, 2000 )
			.easing( TWEEN.Easing.Elastic.Out).start();

		}

		/*
		// Parse all the faces
		for ( var i in intersects ) {

			intersects[ i ].face.material[ 0 ].color.setHex( Math.random() * 0xffffff | 0x80000000 );

		}
		*/
	}

	//

	function animate() {

		requestAnimationFrame( animate );

		render();
		stats.update();

	}

	var radius = 60;
	var theta = 0;

	function render() {

		TWEEN.update();

		theta += 0.1;

		camera.position.x = radius * Math.sin( THREE.Math.degToRad( theta ) );
		camera.position.y = radius * Math.sin( THREE.Math.degToRad( theta ) );
		//camera.position.z = radius * Math.cos( THREE.Math.degToRad( theta ) );
		camera.lookAt( scene.position );

		renderer.render( scene, camera );

	}

	</script>
</body>
</html>
