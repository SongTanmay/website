<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>coming soon !!!</title>
	<link href='http://fonts.googleapis.com/css?family=Quicksand' rel='stylesheet' type='text/css'>
	<style>
		body {
			font-family: 'Quicksand', sans-serif;
		}
		#header_footer_section {
			z-index: 1;
			position: fixed;
			width: 100%;
		}
		header {
			color:#000;
			font-size: 2em;
			width: 80%;
			margin: auto;
			position: fixed;
		}
		footer {
		  bottom: 0;
		  background-color: #efefef;
		  text-align: center;
			width: 80%;
			margin: auto;
			position: fixed;
		}
		#rec_container_section{
			width: 100%;
		}
		#rec{
			width: 80%;
		}
	</style>
</head>

<body>

	<section id='header_footer_section'>
		<header>
			<img src="img/frame.png" alt="frame" data-parallax='{"x": 0, "from-scroll": 50, "distance": 0, "smoothness": 10}'
						data-0="background-image:linear-gradient(0deg, hsl(150, 2%, 100%), hsl(150, 2%, 100%));"
						data-200="background-image:linear-gradient(360deg, hsl(150, 90%, 50%), hsl(150, 90%, 50%));"/>
			<img src="img/t.png" alt="t" data-parallax='{"x": -160, "from-scroll": 70, "distance": 0, "smoothness": 20}'/>
			<img src="img/s.png" alt="s" data-parallax='{"x": -226, "from-scroll": 90, "distance": 0, "smoothness": 30}'/>
			<div style="float: right;" data-parallax='{"y": 110, "from-scroll": 50, "distance": 0, "smoothness": 40}'>
				"Everything is a function of time"
			</div>
		</header>
		<footer>
  	<p>todo</p>
		</footer>
	</section>

	<section id=rec_container_section>
		<div id='rec'>
			<canvas id='canvasID' style=""></canvas>
		</div>
	</section>

	<script src="js/jquery-2.1.3.min.js"></script>
	<script src="js/jquery.easing.1.3.js"></script>
	<script src="js/jquery.parallax-scroll.js"></script>
	<script src="js/skrollr.js"></script>
	<script type="text/javascript">
		skrollr.init();
	</script>
	<script src="js/three.js"></script>
	<script src="js/Projector.js"></script>
	<script src="js/CanvasRenderer.js"></script>
	<script src="js/stats.min.js"></script>
	<script src="js/tween.min.js"></script>
	<script src="js/threex.dynamictexture.js"></script>

	<script>
	var container, stats;
	var camera, scene, renderer;

	var raycaster;
	var mouse;

	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;
	var mouseX = 0, mouseY = 0;
	var updateFcts	= [];
	var dev = ['.js','.rb','.c','.json'];
	var designer = ['.ai','.psd','.indd','.pdf'];
	var photographer = ['.jpeg','.png','.NEF'];
	var dynamicTexture = [];
	var material = [];

	init();
	animate();

	function drawDynamicTexture(i){
		dynamicTexture[i]	= new THREEx.DynamicTexture(512,512)
		dynamicTexture[i].context.font	= "200px Verdana";
		//dynamicTexture.texture.anisotropy = renderer.getMaxAnisotropy()
		updateFcts.push(function(delta, now){
			// build the text which contains the time
			var present	= new Date()
			var text	= dev[Math.floor(Math.random() * dev.length)];
			function pad(n, width, z) {
				z = z || '0';
				n = n + '';
				return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
			}
			// update the text
			dynamicTexture[i].clear('#FF9800')
				.drawText(text, undefined, 256, '#efefef')
		})

		material[i]	= new THREE.MeshBasicMaterial({
			map	: dynamicTexture[i].texture
		})
	}

	function init() {

		container = document.getElementById('rec');
		//container = document.createElement( 'div' );
		document.getElementById('rec_container_section').appendChild( container );

		/*var info = document.createElement( 'div' );
		info.style.position = 'absolute';
		info.style.top = '10px';
		info.style.width = '100%';
		info.style.textAlign = 'center';
		info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - clickable objects';
		container.appendChild( info );*/

		camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.y = 100;
		camera.position.z = 500;

		scene = new THREE.Scene();


		var geometry = new THREE.BoxGeometry( 200, 200, 10 );

		for(i = 1; i < 4 ;i ++){
			drawDynamicTexture(i);
		}



			//var object1 = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, opacity: 0.6 } ) );
			var object1 = new THREE.Mesh( geometry, material[1]);
			//object.position.x = Math.random() * 800 - 400;
			object1.position.x = -300;
			//object1.position.y = object1.position.x + 150;
			object1.position.z = -100;
			//object1.scale.x = Math.random() * 2 + 1;
			//object.scale.y = Math.random() * 2 + 1;
			//object.scale.z = Math.random() * 2 + 1;
			//object.rotation.x = Math.random() * 2 * Math.PI;
			//object.rotation.y = Math.random() * 2 * Math.PI;
			//object.rotation.z = Math.random() * 2 * Math.PI;
			scene.add( object1 );

		var object2 = new THREE.Mesh( geometry,material[2] );
		object2.position.x = object1.position.x + 180;
	//	object2.position.y = object2.position.x + 150;
		object2.position.z = 100;
		scene.add( object2 );
		var object3 = new THREE.Mesh( geometry, material[3] );
		object3.position.x = object1.position.x + 360;
		//object3.position.y = object3.position.x + 150;
		object3.position.z = -100;
		scene.add( object3 );

		//


		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		var canvas = document.getElementById("canvasID");
		renderer = new THREE.CanvasRenderer({ canvas: canvas });
		//renderer = new THREE.CanvasRenderer();
		renderer.setClearColor( 0xf0f0f0 );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, document.body.clientHeight );
		container.appendChild(renderer.domElement);


		stats = new Stats();
		//container.appendChild( stats.dom );

		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'touchstart', onDocumentTouchStart, false );
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );

		//

		window.addEventListener( 'resize', onWindowResize, false );
		updateFcts.push(function(delta, now){
		camera.position.x += (mouse.x*5 - camera.position.x) * (delta*3)
		camera.position.y += (mouse.y*5 - camera.position.y) * (delta*3)
		camera.lookAt( scene.position )
	})

	}

	function onWindowResize() {
		windowHalfX = window.innerWidth / 2;
		windowHalfY = window.innerHeight / 2;

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function onDocumentMouseMove( event ) {
		mouseX = event.clientX - windowHalfX;
		mouseY = event.clientY - windowHalfY;
	}

	function onDocumentTouchStart( event ) {

		event.preventDefault();

		event.clientX = event.touches[0].clientX;
		event.clientY = event.touches[0].clientY;
		onDocumentMouseDown( event );

	}

	function onDocumentMouseDown( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( scene.children );

		if ( intersects.length > 0 && intersects[ 0 ].object.position.z <= 10) {

			new TWEEN.Tween( intersects[ 0 ].object.position ).to( {
				x: intersects[ 0 ].object.position.x,
				y: intersects[ 0 ].object.position.y,
				z: 100 }, 3000 )
			.easing( TWEEN.Easing.Elastic.Out).start();

			//new TWEEN.Tween( intersects[ 0 ].object.rotation ).to( {
			//	x: Math.random() * 2 * Math.PI,
			//	y: Math.random() * 2 * Math.PI,
			//	z: Math.random() * 2 * Math.PI }, 2000 )
		//	.easing( TWEEN.Easing.Elastic.Out).start();

			scene.traverse( function( node ) {

            if ( node instanceof THREE.Mesh ) {

                if ( node != intersects[ 0 ].object){

                 new TWEEN.Tween( node.position ).to( {
                    x: node.position.x,
                    y: node.position.y,
                    z: 0 }, 3000 )
                 .easing( TWEEN.Easing.Elastic.Out).start();

                }
            }

        } );

		}

		/*
		// Parse all the faces
		for ( var i in intersects ) {

			intersects[ i ].face.material[ 0 ].color.setHex( Math.random() * 0xffffff | 0x80000000 );

		}
		*/
	}

	//

	function animate() {

		setTimeout( function() {

        requestAnimationFrame( animate );

    }, 1000 / 2 );

		render();
		stats.update();

	}

	var radius = 60;
	var theta = 0;

	function render() {

		TWEEN.update();

		theta += 0.1;


		camera.position.x += ( mouseX - camera.position.x ) * 0.05;
		camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

		//camera.position.x = radius * Math.sin( THREE.Math.degToRad( theta ) );
		//camera.position.y = radius * Math.sin( THREE.Math.degToRad( theta ) );
		//camera.position.z = radius * Math.cos( THREE.Math.degToRad( theta ) );
		camera.lookAt( scene.position );


		renderer.render( scene, camera );

	}

	function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration)
	{
		// note: texture passed by reference, will be updated by the update function.

		this.tilesHorizontal = tilesHoriz;
		this.tilesVertical = tilesVert;
		// how many images does this spritesheet contain?
		//  usually equals tilesHoriz * tilesVert, but not necessarily,
		//  if there at blank tiles at the bottom of the spritesheet.
		this.numberOfTiles = numTiles;
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

		// how long should each image be displayed?
		this.tileDisplayDuration = tileDispDuration;

		// how long has the current image been displayed?
		this.currentDisplayTime = 0;

		// which image is currently being displayed?
		this.currentTile = 0;

		this.update = function( milliSec )
		{
			this.currentDisplayTime += milliSec;
			while (this.currentDisplayTime > this.tileDisplayDuration)
			{
				this.currentDisplayTime -= this.tileDisplayDuration;
				this.currentTile++;
				if (this.currentTile == this.numberOfTiles)
					this.currentTile = 0;
				var currentColumn = this.currentTile % this.tilesHorizontal;
				texture.offset.x = currentColumn / this.tilesHorizontal;
				var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
				texture.offset.y = currentRow / this.tilesVertical;
			}
		};
	}

	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		updateFcts.forEach(function(updateFn){
			updateFn(deltaMsec/1000, nowMsec/1000)
		})
	})

	</script>
</body>
</html>
